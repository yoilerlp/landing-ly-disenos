<section class='hero-3d w-full h-full'>
  <canvas id='hero-canvas'></canvas>
</section>

<style>
  .hero-3d {
    width: 100%;
  }
  #hero-canvas {
    width: 100%;
    height: 100%;
    display: block;
    position: relative;
  }
</style>

<script>
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

  let scene: THREE.Scene,
    camera: THREE.PerspectiveCamera,
    renderer: THREE.WebGLRenderer;
  let model: THREE.Group | null = null;

  // --- Rotación inicial del modelo ---
  const initialRotX = Math.PI / 2; // enderezarlo
  const initialRotY = Math.PI / 2; // que mire hacia el frente

  // --- Targets que inician en la rotación inicial ---
  let targetRotX = initialRotX;
  let targetRotY = initialRotY;

  const MAX_VERTICAL_ROT = 1; // límite vertical de inclinación
  let trackingEnabled = false; // tracking solo cuando hay hover

  // --- Auto-rotación ---
  let autoRotate = false;
  let lastHoverTime = Date.now();
  const IDLE_TIME_MS = 10000; // 10 segundos en milisegundos

  const init = () => {
    const canvas = document.getElementById('hero-canvas') as HTMLCanvasElement;

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(
      45,
      canvas.clientWidth / canvas.clientHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 4);

    renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
    });
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    // --- Luces ---
    const modelcolor = 0x062854;
    const dir = new THREE.DirectionalLight(modelcolor);
    dir.position.set(2, 3, 4);
    scene.add(dir);
    scene.add(new THREE.AmbientLight(modelcolor));

    // --- Cargar modelo ---
    const loader = new GLTFLoader();
    loader.load(
      '/ft.glb',
      (gltf) => {
        model = gltf.scene;

        model.position.set(0, 0, 0);
        model.rotation.x = initialRotX;
        model.rotation.y = initialRotY;

        model.scale.set(0.045, 0.045, 0.045);

        scene.add(model);
      },
      undefined,
      (error) => console.error('Error cargando GLB:', error)
    );

    // --- Eventos de hover ---
    canvas.addEventListener('mouseenter', () => {
      trackingEnabled = true;
      autoRotate = false; // Detener auto-rotación cuando hay hover
      lastHoverTime = Date.now(); // Actualizar el tiempo del último hover
    });

    canvas.addEventListener('mouseleave', () => {
      trackingEnabled = false;
      lastHoverTime = Date.now(); // Actualizar el tiempo al salir del hover

      // volver suave al estado inicial
      targetRotX = initialRotX;
      targetRotY = initialRotY;
    });

    // --- Mouse ---
    window.addEventListener('mousemove', (e) => {
      if (!trackingEnabled) return;

      lastHoverTime = Date.now(); // Actualizar el tiempo con cada movimiento del mouse
      autoRotate = false; // Detener auto-rotación durante la interacción

      const rect = canvas.getBoundingClientRect();

      const x = (e.clientX - rect.left) / rect.width;
      const y = (e.clientY - rect.top) / rect.height;

      const normX = x * 2 - 1;
      const normY = -(y * 2 - 1);

      const intensity = 1.2;

      // rotación horizontal sobre Y
      targetRotY = initialRotY + normX * intensity;

      // rotación vertical con inversión y límite
      let vertical = -normY * intensity;
      vertical = Math.max(
        -MAX_VERTICAL_ROT,
        Math.min(MAX_VERTICAL_ROT, vertical)
      );

      targetRotX = initialRotX + vertical;
    });

    animate();
  };

  const animate = () => {
    requestAnimationFrame(animate);

    // Verificar si han pasado 30 segundos sin hover
    const timeSinceLastHover = Date.now() - lastHoverTime;
    if (timeSinceLastHover >= IDLE_TIME_MS && !trackingEnabled) {
      autoRotate = true;
    }

    if (model) {
      const smooth = 0.08;

      if (autoRotate) {
        // Auto-rotación horizontal continua
        model.rotation.y += 0.005; // Velocidad de rotación automática

        // Mantener X en posición inicial
        model.rotation.x += (initialRotX - model.rotation.x) * smooth;
      } else {
        // interpolar suavemente hacia la pose deseada
        model.rotation.x += (targetRotX - model.rotation.x) * smooth;
        model.rotation.y += (targetRotY - model.rotation.y) * smooth;
      }
    }

    renderer.render(scene, camera);
  };

  window.addEventListener('load', init);

  // --- Resize handler ---
  window.addEventListener('resize', () => {
    const canvas = document.getElementById('hero-canvas') as HTMLCanvasElement;
    if (!renderer || !camera) return;

    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
  });

  document.addEventListener('astro:after-swap', init);
</script>
